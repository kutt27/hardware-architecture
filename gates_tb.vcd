$date
	Wed Nov 26 09:57:22 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module gates_tb $end
$var wire 8 ! xor_out [7:0] $end
$var wire 8 " xnor_out [7:0] $end
$var wire 8 # tri_out [7:0] $end
$var wire 8 $ or_out [7:0] $end
$var wire 8 % not_out [7:0] $end
$var wire 8 & nor_out [7:0] $end
$var wire 8 ' nand_out [7:0] $end
$var wire 8 ( buf_out [7:0] $end
$var wire 8 ) and_out [7:0] $end
$var reg 8 * a [7:0] $end
$var reg 8 + b [7:0] $end
$var reg 1 , tri_enable $end
$var integer 32 - errors [31:0] $end
$var integer 32 . tests [31:0] $end
$scope module dut_and $end
$var wire 8 / a [7:0] $end
$var wire 8 0 b [7:0] $end
$var wire 8 1 y [7:0] $end
$var parameter 32 2 WIDTH $end
$upscope $end
$scope module dut_buf $end
$var wire 8 3 a [7:0] $end
$var wire 8 4 y [7:0] $end
$var parameter 32 5 WIDTH $end
$upscope $end
$scope module dut_nand $end
$var wire 8 6 a [7:0] $end
$var wire 8 7 b [7:0] $end
$var wire 8 8 y [7:0] $end
$var parameter 32 9 WIDTH $end
$upscope $end
$scope module dut_nor $end
$var wire 8 : a [7:0] $end
$var wire 8 ; b [7:0] $end
$var wire 8 < y [7:0] $end
$var parameter 32 = WIDTH $end
$upscope $end
$scope module dut_not $end
$var wire 8 > a [7:0] $end
$var wire 8 ? y [7:0] $end
$var parameter 32 @ WIDTH $end
$upscope $end
$scope module dut_or $end
$var wire 8 A a [7:0] $end
$var wire 8 B b [7:0] $end
$var wire 8 C y [7:0] $end
$var parameter 32 D WIDTH $end
$upscope $end
$scope module dut_tri $end
$var wire 8 E a [7:0] $end
$var wire 1 , enable $end
$var wire 8 F y [7:0] $end
$var parameter 32 G WIDTH $end
$upscope $end
$scope module dut_xnor $end
$var wire 8 H a [7:0] $end
$var wire 8 I b [7:0] $end
$var wire 8 J y [7:0] $end
$var parameter 32 K WIDTH $end
$upscope $end
$scope module dut_xor $end
$var wire 8 L a [7:0] $end
$var wire 8 M b [7:0] $end
$var wire 8 N y [7:0] $end
$var parameter 32 O WIDTH $end
$upscope $end
$scope task check_result $end
$var reg 8 P actual [7:0] $end
$var reg 8 Q expected [7:0] $end
$var reg 640 R test_name [639:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1000 O
b1000 K
b1000 G
b1000 D
b1000 @
b1000 =
b1000 9
b1000 5
b1000 2
$end
#0
$dumpvars
bx R
bx Q
bx P
b0 N
b0 M
b0 L
b11111111 J
b0 I
b0 H
bz F
b0 E
b0 C
b0 B
b0 A
b11111111 ?
b0 >
b11111111 <
b0 ;
b0 :
b11111111 8
b0 7
b0 6
b0 4
b0 3
b0 1
b0 0
b0 /
b0 .
b0 -
0,
b0 +
b0 *
b0 )
b0 (
b11111111 '
b11111111 &
b11111111 %
b0 $
bz #
b11111111 "
b0 !
$end
#20000
b0 '
b0 8
b0 &
b0 <
b11111111 )
b11111111 1
b0 %
b0 ?
b11111111 $
b11111111 C
b11111111 +
b11111111 0
b11111111 7
b11111111 ;
b11111111 B
b11111111 I
b11111111 M
b11111111 (
b11111111 4
b11111111 *
b11111111 /
b11111111 3
b11111111 6
b11111111 :
b11111111 >
b11111111 A
b11111111 E
b11111111 H
b11111111 L
b111 .
b10110000100111001001111010100100011101000100000011111100010100000110000011110000011000000110000001000000101111000100000001100000111100000110000001100000010100100100000001111010010000000110000011110000100011001000110 R
b11111111 P
b11111111 Q
#30000
b11111111 '
b11111111 8
b0 "
b0 J
b0 )
b0 1
b1010101 %
b1010101 ?
b11111111 !
b11111111 N
b1010101 +
b1010101 0
b1010101 7
b1010101 ;
b1010101 B
b1010101 I
b1010101 M
b10101010 (
b10101010 4
b10101010 *
b10101010 /
b10101010 3
b10101010 6
b10101010 :
b10101010 >
b10101010 A
b10101010 E
b10101010 H
b10101010 L
b11111111 P
b11111111 Q
b1110 .
b10110000100111001001111010100100011101000100000011111100010100000110000011110000100011001000110001000000101111000100000001100000111100001000110010001100010100100100000001111010010000000110000011110000100011001000110 R
#40000
b1111 %
b1111 ?
b1111 +
b1111 0
b1111 7
b1111 ;
b1111 B
b1111 I
b1111 M
b11110000 (
b11110000 4
b11110000 *
b11110000 /
b11110000 3
b11110000 6
b11110000 :
b11110000 >
b11110000 A
b11110000 E
b11110000 H
b11110000 L
b10101 .
b10110000100111001001111010100100011101000100000011111100010100000110000011110000100000101000001001000000101111000100000001100000111100000110101001101010010100100100000001111010010000000110000011110000011000000110000 R
b0 P
b0 Q
#50000
b1110111 '
b1110111 8
b10001 &
b10001 <
b10011001 "
b10011001 J
b10001000 )
b10001000 1
b110011 %
b110011 ?
b11101110 $
b11101110 C
b1100110 !
b1100110 N
b10101010 +
b10101010 0
b10101010 7
b10101010 ;
b10101010 B
b10101010 I
b10101010 M
b11001100 (
b11001100 4
b11001100 *
b11001100 /
b11001100 3
b11001100 6
b11001100 :
b11001100 >
b11001100 A
b11001100 E
b11001100 H
b11001100 L
b11111111 P
b11111111 Q
b11001 .
b101100001001111010100100011101000100000001100000111100001000110001100000010000001011110001000000011000001111000001100000100011000100000001111010010000000110000011110000100011001000110 R
#60000
b11110101 '
b11110101 8
b101 &
b101 <
b1111 "
b1111 J
b1010 )
b1010 1
b10100101 %
b10100101 ?
b11111010 $
b11111010 C
b11110000 !
b11110000 N
b1011010 (
b1011010 4
b1011010 *
b1011010 /
b1011010 3
b1011010 6
b1011010 :
b1011010 >
b1011010 A
b1011010 E
b1011010 H
b1011010 L
b11100 .
b101100001001111010100100011101000100000001100000111100001000011010000110010000001011110001000000011000001111000010000010100000100100000001111010010000000110000011110000011011000110110 R
b1100110 P
b1100110 Q
#70000
b1011111 '
b1011111 8
b1010000 &
b1010000 <
b11110000 "
b11110000 J
b10100000 )
b10100000 1
b1011010 %
b1011010 ?
b10101111 $
b10101111 C
b1111 !
b1111 N
b10100101 (
b10100101 4
b10100101 *
b10100101 /
b10100101 3
b10100101 6
b10100101 :
b10100101 >
b10100101 A
b10100101 E
b10100101 H
b10100101 L
b11101 .
b100001001010101010001100100011001000101010100100011101000100000001100000111100000110101010000010010000000101101001111100010000000110000011110000011010101000001 R
b1011010 P
b1011010 Q
#80000
b11111101 '
b11111101 8
b10101 &
b10101 <
b10111 "
b10111 J
b1000010 #
b1000010 F
b10 )
b10 1
b10111101 %
b10111101 ?
b11101010 $
b11101010 C
b11101000 !
b11101000 N
1,
b1000010 (
b1000010 4
b1000010 *
b1000010 /
b1000010 3
b1000010 6
b1000010 :
b1000010 >
b1000010 A
b1000010 E
b1000010 H
b1000010 L
b11110 .
b100001001010101010001100100011001000101010100100011101000100000001100000111100001000001001101010010000000101101001111100010000000110000011110000100000100110101 R
b10100101 P
b10100101 Q
#90000
bz #
bz F
0,
b11111 .
b10101000101001001001001001011010101001101010100010000010101010001000101001000000010100001100101011011100110000101100010011011000110010101100100001010010011101000100000001100000111100000110100001100100010000000101101001111100010000000110000011110000011010000110010 R
b1000010 P
b1000010 Q
#100000
b11111111 '
b11111111 8
b1011010 &
b1011010 <
b1011010 "
b1011010 J
b0 )
b0 1
b11011011 %
b11011011 ?
b10100101 $
b10100101 C
b10100101 !
b10100101 N
b10000001 +
b10000001 0
b10000001 7
b10000001 ;
b10000001 B
b10000001 I
b10000001 M
b100100 (
b100100 4
b100100 *
b100100 /
b100100 3
b100100 6
b100100 :
b100100 >
b100100 A
b100100 E
b100100 H
b100100 L
b100000 .
#110000
b11111110 '
b11111110 8
b10010100 &
b10010100 <
b10010101 "
b10010101 J
b1 )
b1 1
b11110110 %
b11110110 ?
b1101011 $
b1101011 C
b1101010 !
b1101010 N
b1100011 +
b1100011 0
b1100011 7
b1100011 ;
b1100011 B
b1100011 I
b1100011 M
b1001 (
b1001 4
b1001 *
b1001 /
b1001 3
b1001 6
b1001 :
b1001 >
b1001 A
b1001 E
b1001 H
b1001 L
b100011 .
#120000
b11110010 '
b11110010 8
b1110010 &
b1110010 <
b1111111 "
b1111111 J
b1101 )
b1101 1
b11110010 %
b11110010 ?
b10001101 $
b10001101 C
b10000000 !
b10000000 N
b10001101 +
b10001101 0
b10001101 7
b10001101 ;
b10001101 B
b10001101 I
b10001101 M
b1101 (
b1101 4
b1101 *
b1101 /
b1101 3
b1101 6
b1101 :
b1101 >
b1101 A
b1101 E
b1101 H
b1101 L
b100110 .
#130000
b11111111 '
b11111111 8
b10001000 &
b10001000 <
b10001000 "
b10001000 J
b0 )
b0 1
b10011010 %
b10011010 ?
b1110111 $
b1110111 C
b1110111 !
b1110111 N
b10010 +
b10010 0
b10010 7
b10010 ;
b10010 B
b10010 I
b10010 M
b1100101 (
b1100101 4
b1100101 *
b1100101 /
b1100101 3
b1100101 6
b1100101 :
b1100101 >
b1100101 A
b1100101 E
b1100101 H
b1100101 L
b101001 .
#140000
b11111110 '
b11111110 8
b11110010 &
b11110010 <
b11110011 "
b11110011 J
b1 )
b1 1
b11111110 %
b11111110 ?
b1101 $
b1101 C
b1100 !
b1100 N
b1101 +
b1101 0
b1101 7
b1101 ;
b1101 B
b1101 I
b1101 M
b1 (
b1 4
b1 *
b1 /
b1 3
b1 6
b1 :
b1 >
b1 A
b1 E
b1 H
b1 L
b101100 .
#150000
b11001011 '
b11001011 8
b10000000 &
b10000000 <
b10110100 "
b10110100 J
b110100 )
b110100 1
b10001001 %
b10001001 ?
b1111111 $
b1111111 C
b1001011 !
b1001011 N
b111101 +
b111101 0
b111101 7
b111101 ;
b111101 B
b111101 I
b111101 M
b1110110 (
b1110110 4
b1110110 *
b1110110 /
b1110110 3
b1110110 6
b1110110 :
b1110110 >
b1110110 A
b1110110 E
b1110110 H
b1110110 L
b101111 .
#160000
b1110011 '
b1110011 8
b10010 &
b10010 <
b10011110 "
b10011110 J
b10001100 )
b10001100 1
b10010 %
b10010 ?
b11101101 $
b11101101 C
b1100001 !
b1100001 N
b10001100 +
b10001100 0
b10001100 7
b10001100 ;
b10001100 B
b10001100 I
b10001100 M
b11101101 (
b11101101 4
b11101101 *
b11101101 /
b11101101 3
b11101101 6
b11101101 :
b11101101 >
b11101101 A
b11101101 E
b11101101 H
b11101101 L
b110010 .
#170000
b111111 '
b111111 8
b0 &
b0 <
b11000000 "
b11000000 J
b11000000 )
b11000000 1
b110 %
b110 ?
b11111111 $
b11111111 C
b111111 !
b111111 N
b11000110 +
b11000110 0
b11000110 7
b11000110 ;
b11000110 B
b11000110 I
b11000110 M
b11111001 (
b11111001 4
b11111001 *
b11111001 /
b11111001 3
b11111001 6
b11111001 :
b11111001 >
b11111001 A
b11111001 E
b11111001 H
b11111001 L
b110101 .
#180000
b1111111 '
b1111111 8
b10000 &
b10000 <
b10010000 "
b10010000 J
b10000000 )
b10000000 1
b111010 %
b111010 ?
b11101111 $
b11101111 C
b1101111 !
b1101111 N
b10101010 +
b10101010 0
b10101010 7
b10101010 ;
b10101010 B
b10101010 I
b10101010 M
b11000101 (
b11000101 4
b11000101 *
b11000101 /
b11000101 3
b11000101 6
b11000101 :
b11000101 >
b11000101 A
b11000101 E
b11000101 H
b11000101 L
b111000 .
#190000
b10011010 '
b10011010 8
b1000 &
b1000 <
b1101101 "
b1101101 J
b1100101 )
b1100101 1
b11010 %
b11010 ?
b11110111 $
b11110111 C
b10010010 !
b10010010 N
b1110111 +
b1110111 0
b1110111 7
b1110111 ;
b1110111 B
b1110111 I
b1110111 M
b11100101 (
b11100101 4
b11100101 *
b11100101 /
b11100101 3
b11100101 6
b11100101 :
b11100101 >
b11100101 A
b11100101 E
b11100101 H
b11100101 L
b111011 .
#200000
b11111111 '
b11111111 8
b1011010 &
b1011010 <
b1011010 "
b1011010 J
b0 )
b0 1
b1011010 %
b1011010 ?
b10100101 $
b10100101 C
b10100101 !
b10100101 N
b0 +
b0 0
b0 7
b0 ;
b0 B
b0 I
b0 M
b10100101 (
b10100101 4
b10100101 *
b10100101 /
b10100101 3
b10100101 6
b10100101 :
b10100101 >
b10100101 A
b10100101 E
b10100101 H
b10100101 L
b111110 .
#210000
b1011010 '
b1011010 8
b0 &
b0 <
b10100101 "
b10100101 J
b10100101 )
b10100101 1
b11111111 $
b11111111 C
b1011010 !
b1011010 N
b11111111 +
b11111111 0
b11111111 7
b11111111 ;
b11111111 B
b11111111 I
b11111111 M
b111111 .
b1001001011001000110010101101110011101000110100101110100011110010011101000100000010000010010000000100110001000000011000000100000001111010010000000110000 R
b0 P
b0 Q
#220000
b1011010 &
b1011010 <
b11111111 "
b11111111 J
b10100101 $
b10100101 C
b0 !
b0 N
b10100101 +
b10100101 0
b10100101 7
b10100101 ;
b10100101 B
b10100101 I
b10100101 M
b1000001 .
b1001001011001000110010101101110011101000110100101110100011110010011101000100000010000010010000001111100001000000011000100100000001111010010000000110001 R
b11111111 P
b11111111 Q
#230000
b1000100 .
b10000110110111101101101011100000110110001100101011011010110010101101110011101000011101000100000010000010010000001011110001000000100000100100000001111010010000000110000 R
b0 P
b0 Q
