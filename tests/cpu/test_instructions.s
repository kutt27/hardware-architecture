; =============================================================================
; ARM7 Instruction Test Suite
; =============================================================================
; Description:
;   Comprehensive test of all ARM7 instructions implemented in the CPU.
;   Tests data processing, load/store, branches, and condition codes.
;
; Author: ARM7 Computer System Project
; Date: 2025-11-03
; =============================================================================

.text
.global _start

_start:
    ; Initialize test counter
    MOV R12, ;0         ; R12 = test counter

; =============================================================================
; Test 1: MOV Instruction
; =============================================================================
test_mov:
    MOV R0, ;42         ; R0 = 42
    MOV R1, R0          ; R1 = R0
    ADD R12, R12, ;1    ; Increment test counter

; =============================================================================
; Test 2: ADD Instruction
; =============================================================================
test_add:
    MOV R0, ;10         ; R0 = 10
    MOV R1, ;20         ; R1 = 20
    ADD R2, R0, R1      ; R2 = R0 + R1 = 30
    ADD R12, R12, ;1

; =============================================================================
; Test 3: SUB Instruction
; =============================================================================
test_sub:
    MOV R0, ;50         ; R0 = 50
    MOV R1, ;30         ; R1 = 30
    SUB R2, R0, R1      ; R2 = R0 - R1 = 20
    ADD R12, R12, ;1

; =============================================================================
; Test 4: AND Instruction
; =============================================================================
test_and:
    MOV R0, ;0xFF       ; R0 = 0xFF
    MOV R1, ;0x0F       ; R1 = 0x0F
    AND R2, R0, R1      ; R2 = R0 AND R1 = 0x0F
    ADD R12, R12, ;1

; =============================================================================
; Test 5: ORR Instruction
; =============================================================================
test_orr:
    MOV R0, ;0xF0       ; R0 = 0xF0
    MOV R1, ;0x0F       ; R1 = 0x0F
    ORR R2, R0, R1      ; R2 = R0 OR R1 = 0xFF
    ADD R12, R12, ;1

; =============================================================================
; Test 6: EOR Instruction
; =============================================================================
test_eor:
    MOV R0, ;0xFF       ; R0 = 0xFF
    MOV R1, ;0x0F       ; R1 = 0x0F
    EOR R2, R0, R1      ; R2 = R0 XOR R1 = 0xF0
    ADD R12, R12, ;1

; =============================================================================
; Test 7: MVN Instruction
; =============================================================================
test_mvn:
    MOV R0, ;0          ; R0 = 0
    MVN R1, R0          ; R1 = NOT R0 = 0xFFFFFFFF
    ADD R12, R12, ;1

; =============================================================================
; Test 8: CMP Instruction (Sets Flags)
; =============================================================================
test_cmp:
    MOV R0, ;10         ; R0 = 10
    MOV R1, ;10         ; R1 = 10
    CMP R0, R1          ; Compare R0 and R1 (should set Z flag)
    ADD R12, R12, ;1

; =============================================================================
; Test 9: Conditional Execution (EQ)
; =============================================================================
test_conditional_eq:
    MOV R0, ;5          ; R0 = 5
    MOV R1, ;5          ; R1 = 5
    CMP R0, R1          ; Compare (Z=1)
    MOVEQ R2, ;1        ; R2 = 1 (should execute)
    MOVNE R2, ;0        ; R2 = 0 (should NOT execute)
    ADD R12, R12, ;1

; =============================================================================
; Test 10: Conditional Execution (NE)
; =============================================================================
test_conditional_ne:
    MOV R0, ;5          ; R0 = 5
    MOV R1, ;10         ; R1 = 10
    CMP R0, R1          ; Compare (Z=0)
    MOVEQ R3, ;0        ; R3 = 0 (should NOT execute)
    MOVNE R3, ;1        ; R3 = 1 (should execute)
    ADD R12, R12, ;1

; =============================================================================
; Test 11: Shift Left Logical (LSL)
; =============================================================================
test_lsl:
    MOV R0, ;1          ; R0 = 1
    MOV R1, R0, LSL ;3  ; R1 = R0 << 3 = 8
    ADD R12, R12, ;1

; =============================================================================
; Test 12: Shift Right Logical (LSR)
; =============================================================================
test_lsr:
    MOV R0, ;16         ; R0 = 16
    MOV R1, R0, LSR ;2  ; R1 = R0 >> 2 = 4
    ADD R12, R12, ;1

; =============================================================================
; Test 13: Arithmetic Shift Right (ASR)
; =============================================================================
test_asr:
    MOV R0, ;0x80000000 ; R0 = negative number
    MOV R1, R0, ASR ;1  ; R1 = R0 >>> 1 (sign-extended)
    ADD R12, R12, ;1

; =============================================================================
; Test 14: Rotate Right (ROR)
; =============================================================================
test_ror:
    MOV R0, ;0x00000001 ; R0 = 1
    MOV R1, R0, ROR ;1  ; R1 = rotate right by 1
    ADD R12, R12, ;1

; =============================================================================
; Test 15: ADD with Carry (ADC)
; =============================================================================
test_adc:
    MOV R0, ;10         ; R0 = 10
    MOV R1, ;20         ; R1 = 20
    ADDS R2, R0, R1     ; R2 = 30, may set carry
    ADC R3, R0, R1      ; R3 = R0 + R1 + C
    ADD R12, R12, ;1

; =============================================================================
; Test 16: SUB with Carry (SBC)
; =============================================================================
test_sbc:
    MOV R0, ;50         ; R0 = 50
    MOV R1, ;20         ; R1 = 20
    SUBS R2, R0, R1     ; R2 = 30, may set carry
    SBC R3, R0, R1      ; R3 = R0 - R1 - !C
    ADD R12, R12, ;1

; =============================================================================
; Test 17: Reverse Subtract (RSB)
; =============================================================================
test_rsb:
    MOV R0, ;10         ; R0 = 10
    MOV R1, ;30         ; R1 = 30
    RSB R2, R0, R1      ; R2 = R1 - R0 = 20
    ADD R12, R12, ;1

; =============================================================================
; Test 18: Bit Clear (BIC)
; =============================================================================
test_bic:
    MOV R0, ;0xFF       ; R0 = 0xFF
    MOV R1, ;0x0F       ; R1 = 0x0F
    BIC R2, R0, R1      ; R2 = R0 AND NOT R1 = 0xF0
    ADD R12, R12, ;1

; =============================================================================
; Test 19: Test (TST)
; =============================================================================
test_tst:
    MOV R0, ;0xFF       ; R0 = 0xFF
    MOV R1, ;0x0F       ; R1 = 0x0F
    TST R0, R1          ; Test R0 AND R1 (sets flags, no result)
    ADD R12, R12, ;1

; =============================================================================
; Test 20: Test Equivalence (TEQ)
; =============================================================================
test_teq:
    MOV R0, ;0xFF       ; R0 = 0xFF
    MOV R1, ;0xFF       ; R1 = 0xFF
    TEQ R0, R1          ; Test R0 XOR R1 (should set Z)
    ADD R12, R12, ;1

; =============================================================================
; Test 21: Compare Negative (CMN)
; =============================================================================
test_cmn:
    MOV R0, ;10         ; R0 = 10
    MOV R1, ;10         ; R1 = 10
    CMN R0, R1          ; Compare R0 + R1 (sets flags)
    ADD R12, R12, ;1

; =============================================================================
; Test 22: Load/Store Word
; =============================================================================
test_ldst_word:
    MOV R0, ;0x00010000 ; R0 = data RAM base
    MOV R1, ;42         ; R1 = value to store
    STR R1, [R0]        ; Store R1 to [R0]
    MOV R2, ;0          ; R2 = 0
    LDR R2, [R0]        ; Load from [R0] to R2 (should be 42)
    ADD R12, R12, ;1

; =============================================================================
; Test 23: Load/Store with Offset
; =============================================================================
test_ldst_offset:
    MOV R0, ;0x00010000 ; R0 = base address
    MOV R1, ;100        ; R1 = value
    STR R1, [R0, ;4]    ; Store to [R0 + 4]
    LDR R2, [R0, ;4]    ; Load from [R0 + 4]
    ADD R12, R12, ;1

; =============================================================================
; Test 24: Load/Store Byte
; =============================================================================
test_ldst_byte:
    MOV R0, ;0x00010000 ; R0 = base address
    MOV R1, ;0xFF       ; R1 = 0xFF
    STRB R1, [R0]       ; Store byte
    MOV R2, ;0          ; R2 = 0
    LDRB R2, [R0]       ; Load byte (should be 0xFF)
    ADD R12, R12, ;1

; =============================================================================
; Test 25: Branch
; =============================================================================
test_branch:
    B skip_code         ; Branch over next instruction
    MOV R0, ;99         ; Should be skipped
skip_code:
    MOV R0, ;1          ; Should execute
    ADD R12, R12, ;1

; =============================================================================
; Test 26: Branch with Link (Function Call)
; =============================================================================
test_bl:
    BL function         ; Call function
    ADD R12, R12, ;1
    B test_end

function:
    MOV R0, ;123        ; Do something
    MOV PC, LR          ; Return

; =============================================================================
; Test 27: Loop Test
; =============================================================================
test_loop:
    MOV R0, ;0          ; Counter
    MOV R1, ;5          ; Limit
loop:
    ADD R0, R0, ;1      ; Increment
    CMP R0, R1          ; Compare
    BLT loop            ; Loop if less than
    ADD R12, R12, ;1

; =============================================================================
; Test Complete
; =============================================================================
test_end:
    ; R12 should contain the number of tests executed
    ; Expected: 27 tests
    
    ; Infinite loop (halt)
halt:
    B halt

.data
; Test data area
test_data:
    .word 0x12345678
    .word 0xDEADBEEF
    .word 0xCAFEBABE

; =============================================================================
; Expected Results:
;   R12 = 27 (number of tests)
;   All tests should pass if CPU is working correctly
; =============================================================================

